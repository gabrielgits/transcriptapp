{
	"model_create": {
		"prefix": "model",
		"body": [
			"import 'package:freezed_annotation/freezed_annotation.dart';",
			"import 'package:flutter/foundation.dart';",
			"",
			"part '${1:filename}_model.freezed.dart';",
			"part '${1:filename}_model.g.dart';",
			"",
			"@freezed",
			"class ${2:ClassName}Model with _$${2:ClassName}Model {",
			"  const factory ${2:ClassName}Model({",
			"    required int id,",
			"    required String name,",
			"    ${3:attributes}",
			"  }) = _${2:ClassName}Model;",
			"",
			"  factory ${2:ClassName}Model.init() {",
			"    return const ${2:ClassName}Model(",
			"      id: 0,",
			"      name: '',",
			"      ${4:initialization}",
			"    );",
			"  }",
			"",
			"  factory ${2:ClassName}Model.fromJson(Map<String, Object?> json) =>",
			"      _$${2:ClassName}ModelFromJson(json);",
			"}",
			""
		],
		"description": "model create"
	},

	"create_view_model": {
		"prefix": "viewmodel",
		"body": [
			"import 'package:bform/bform.dart';",
			"",
			"import '../../domain/models/${1:model}_model.dart';",
			"",
			"class ${2:ModelClass}ViewModel implements BformObj {",
			"  ${2:ModelClass}Model model;",
			"",
			"  ${2:ModelClass}ViewModel(this.model);",
			"",
			"  @override",
			"  int get id => model.id;",
			"",
			"  @override",
			"  String get imagePath => 'assets/images/menu/image.png';",
			"",
			"  @override",
			"  bool isSame(BformObj value) => id == value.id;",
			"",
			"  @override",
			"  String get subtitle => '${model.id}: ${model.name}';",
			"",
			"  @override",
			"  String get title => model.name;",
			"",
			"  @override",
			"  String ToString() => title;",
			"}",
			""
		],
		"description": "create_view_model"
	},

	"create local Repository abstract class": {
		"prefix": "repolc",
		"body": [
		  "import '../models/${1:model}_model.dart';",
		  "",
		  "/// An abstract class that defines the contract for a local repository of ${2:ModelClasse} items.",
		  "/// This repository provides methods for CRUD operations on ${2:ModelClasse} items and lists.",
		  "abstract class RepositoryLocal${3:Feature} {",
		  "  /// Retrieves a [${2:ModelClasse}Model] item by its [id].",
		  "  ///",
		  "  /// - Returns a [Future] that completes with the [${2:ModelClasse}Model] item.",
		  "  /// - Returns a empty [${2:ModelClasse}Model] with ID == 0.",
		  "  Future<${2:ModelClasse}Model> getItem(int id);",
		  "",
		  "  /// Saves a [${2:ModelClasse}Model] item to the repository.",
		  "  ///",
		  "  /// - Returns a [Future] that completes with the ID of the saved item.",
		  "  /// - Returns 0 if not saved.",
		  "  Future<int> saveItem(${2:ModelClasse}Model item);",
		  "",
		  "  /// Updates a [${2:ModelClasse}Model] item in the repository.",
		  "  ///",
		  "  /// - Returns a [Future] that completes with the ID of the updated item.",
		  "  /// - Returns 0 if not updated.",
		  "  Future<int> updateItem(${2:ModelClasse}Model item);",
		  "",
		  "  /// Deletes a [${2:ModelClasse}Model] item by its [id].",
		  "  ///",
		  "  /// - Returns a [Future] that completes with the ID of the updated item.",
		  "  /// - Returns 0 if not deleted.",
		  "  Future<int> deleteItem(int id);",
		  "",
		  "  /// Retrieves a list of all [${2:ModelClasse}Model] items.",
		  "  ///",
		  "  /// - Returns a [Future] that completes with a list of [${2:ModelClasse}Model] items.",
		  "  /// - Returns an empty list if not found.",
		  "  Future<List<${2:ModelClasse}Model>> getList();",
		  "",
		  "  /// Saves a list of [${2:ModelClasse}Model] items to the repository.",
		  "  ///",
		  "  /// - Returns a [Future] that completes with the number of items saved.",
		  "  Future<int> saveList(List<${2:ModelClasse}Model> list);",
		  "",
		  "  /// Updates a list of [${2:ModelClasse}Model] items in the repository.",
		  "  ///",
		  "  /// - Returns a [Future] that completes with the number of items updated.",
		  "  Future<int> updateList(List<${2:ModelClasse}Model> list);",
		  "",
		  "  /// Deletes all [${2:ModelClasse}Model] items from the repository.",
		  "  ///",
		  "  /// - Returns a [Future] that completes with the number of rows affected.",
		  "  Future<int> deleteAll();",
		  "}",
		  "",
		  ""
		],
		"description": "create local Repository abstract class"
	  },

	  "create remote Repository abstract class": {
		"prefix": "reporm",
		"body": [
		  "import '../../domain/models/${1:model}_model.dart';",
		  "",
		  "/// An abstract class that defines the contract for a remote repository of ${2:ClassModel} items.",
		  "/// This repository provides methods for CRUD operations on ${2:ClassModel} items over a network.",
		  "abstract class RepositoryRemote${3:Feature} {",
		  "  /// Retrieves a list of all [${2:ClassModel}Model] items from the remote source.",
		  "  ///",
		  "  /// - Returns a [Future] that completes with a list of [${2:ClassModel}Model] items.",
		  "  /// - Throws an exception if the network request fails.",
		  "  Future<List<${2:ClassModel}Model>> getList();",
		  "",
		  "  /// Retrieves a [${2:ClassModel}Model] item by its [id] from the remote source.",
		  "  ///",
		  "  /// - Returns a [Future] that completes with the [${2:ClassModel}Model] item.",
		  "  /// - Throws an exception if the item is not found or the network request fails.",
		  "  Future<${2:ClassModel}Model> getItem(int id);",
		  "",
		  "  /// Posts a new [${2:ClassModel}Model] item to the remote source.",
		  "  ///",
		  "  /// [jsonData] is a map containing the data to be posted.",
		  "  ///",
		  "  /// - Returns a [Future] that completes with the created [${2:ClassModel}Model] item.",
		  "  /// - Throws an exception if the network request fails.",
		  "  Future<${2:ClassModel}Model> postItem(Map<String, dynamic> jsonData);",
		  "",
		  "  /// Updates an existing [${2:ClassModel}Model] item on the remote source.",
		  "  ///",
		  "  /// [id] is the identifier for the item to be updated.",
		  "  /// [jsonData] is a map containing the updated data.",
		  "  ///",
		  "  /// - Returns a [Future] that completes with the updated [${2:ClassModel}Model] item.",
		  "  /// - Throws an exception if the item is not found or the network request fails.",
		  "  Future<${2:ClassModel}Model> putItem({",
		  "    required int id,",
		  "    required Map<String, dynamic> jsonData,",
		  "  });",
		  "",
		  "  /// Deletes a [${2:ClassModel}Model] item by its [id] from the remote source.",
		  "  ///",
		  "  /// [id] is the identifier for the item to be deleted.",
		  "  ///",
		  "  /// Returns a [Future] that completes with the deleted [${2:ClassModel}Model] item.",
		  "  /// Throws an exception if the item is not found or the network request fails.",
		  "  Future<${2:ClassModel}Model> deleteItem(int id);",
		  "}",
		  "",
		  ""
		],
		"description": "create remote Repository abstract class"
	  },

	  "create local Repository implementation class": {
		"prefix": "repolcImp",
		"body": [
		  "import 'package:feds/feds.dart';",
		  "",
		  "import '../../domain/models/${1:model}_model.dart';",
		  "import '../../domain/repositories/repository_local_${1:model}s.dart';",
		  "",
		  "class RepositoryLocal${2:Feature}Impl implements RepositoryLocal${2:Feature} {",
		  "  final FedsLocal datasource;",
		  "  final table = '${1:model}s';",
		  "",
		  "  RepositoryLocal${2:Feature}Impl(this.datasource);",
		  "",
		  "  @override",
		  "  Future<List<${3:ClassModel}Model>> getList() async {",
		  "    List<${3:ClassModel}Model> list = [];",
		  "    final datas = await datasource.getAll(table);",
		  "    if (datas.isEmpty) {",
		  "      return [];",
		  "    }",
		  "    for (final item in datas) {",
		  "      list.add(${3:ClassModel}Model.fromJson(item));",
		  "    }",
		  "    return list;",
		  "  }",
		  "",
		  "  @override",
		  "  Future<int> saveList(List<${3:ClassModel}Model> list) async {",
		  "    if (list.isEmpty) {",
		  "      return 0;",
		  "    }",
		  "    await datasource.deleteAll(table);",
		  "    final listData = list.map((e) => e.toJson()).toList();",
		  "    return await datasource.saveAll(items: listData, table: table);",
		  "  }",
		  "",
		  "  @override",
		  "  Future<int> updateItem(${3:ClassModel}Model item) async {",
		  "    return await datasource.update(item: item.toJson(), table: table);",
		  "  }",
		  "",
		  "  @override",
		  "  Future<int> saveItem(${3:ClassModel}Model item) async {",
		  "    return await datasource.update(item: item.toJson(), table: table);",
		  "  }",
		  "",
		  "  @override",
		  "  Future<int> deleteAll() async {",
		  "    return await datasource.deleteAll(table);",
		  "  }",
		  "",
		  "  @override",
		  "  Future<int> deleteItem(int id) async {",
		  "    return await datasource.delete(table: table, id: id);",
		  "  }",
		  "",
		  "  @override",
		  "  Future<${3:ClassModel}Model> getItem(int id) async {",
		  "    final data = await datasource.getItem(id: id, table: table);",
		  "    return ${3:ClassModel}Model.fromJson(data);",
		  "  }",
		  "",
		  "  @override",
		  "  Future<int> updateList(List<${3:ClassModel}Model> list) async {",
		  "    if (list.isEmpty) {",
		  "      return 0;",
		  "    }",
		  "    int quant = 0;",
		  "    for (final item in list) {",
		  "      final id = await datasource.update(item: item.toJson(), table: table);",
		  "      if (id > 0) {",
		  "        quant++;",
		  "      }",
		  "    }",
		  "    return quant;",
		  "  }",
		  "}",
		  "",
		  ""
		],
		"description": "create local Repository implementation class"
	  },

	  "create remote Repository implementation class": {
		"prefix": "repormImp",
		"body": [
		  "import 'package:feds/feds.dart';",
		  "import 'package:sfbapp/app/core/constats.dart';",
		  "",
		  "import '../../domain/models/${1:model}_model.dart';",
		  "import '../../domain/repositories/repository_remote_${1:model}s.dart';",
		  "",
		  "class RepositoryRemote${2:Feature}Impl implements RepositoryRemote${2:Feature} {",
		  "  final String name = '${1:model}';",
		  "  final FedsRest datasource;",
		  "  RepositoryRemote${2:Feature}Impl(this.datasource);",
		  "",
		  "  @override",
		  "  Future<List<${3:ClassModel}Model>> getList() async {",
		  "    final response = await datasource.get('${Constats.urlBaseApi}$name');",
		  "    List<${3:ClassModel}Model> list = [];",
		  "    if (response['status'] == false) {",
		  "      throw Exception(response['error']);",
		  "    }",
		  "    for (var item in response['data']) {",
		  "      list.add(${3:ClassModel}Model.fromJson(item));",
		  "    }",
		  "    return list;",
		  "  }",
		  "",
		  "  @override",
		  "  Future<${3:ClassModel}Model> getItem(int id) async {",
		  "    final response = await datasource.get('${Constats.urlBaseApi}$name/$id');",
		  "    if (response['status'] == false) {",
		  "      throw Exception(response['error']);",
		  "    }",
		  "    return ${3:ClassModel}Model.fromJson(response['data']);",
		  "  }",
		  "",
		  "  @override",
		  "  Future<${3:ClassModel}Model> postItem(Map<String, dynamic> jsonData) async {",
		  "    final response =",
		  "        await datasource.post('${Constats.urlBaseApi}$name', jsonData);",
		  "    if (response['status'] == false) {",
		  "      throw Exception(response['error']);",
		  "    }",
		  "    return ${3:ClassModel}Model.fromJson(response['data']);",
		  "  }",
		  "",
		  "  @override",
		  "  Future<${3:ClassModel}Model> deleteItem(int id) async {",
		  "    final response = await datasource.delete('${Constats.urlBaseApi}$name/$id');",
		  "    if (response['status'] == false) {",
		  "      throw Exception(response['error']);",
		  "    }",
		  "    return ${3:ClassModel}Model.fromJson(response['data']);",
		  "  }",
		  "",
		  "  @override",
		  "  Future<${3:ClassModel}Model> putItem({",
		  "    required int id,",
		  "    required Map<String, dynamic> jsonData,",
		  "  }) async {",
		  "    final response =",
		  "        await datasource.put('${Constats.urlBaseApi}$name/$id', jsonData);",
		  "    if (response['status'] == false) {",
		  "      throw Exception(response['error']);",
		  "    }",
		  "    return ${3:ClassModel}Model.fromJson(response['data']);",
		  "  }",
		  "}",
		  ""
		],
		"description": "create remote Repository implementation class"
	  },

	  "create usecase for feature": {
		"prefix": "usecase",
		"body": [
		  "import 'package:expt/expt.dart';",
		  "",
		  "import '../models/${1:model}_model.dart';",
		  "import '../repositories/repository_local_${1:model}s.dart';",
		  "import '../repositories/repository_remote_${1:model}s.dart';",
		  "",
		  "/// A use case class for managing operations related to ${2:Feature}.",
		  "/// It interacts with both local and remote repositories to perform",
		  "/// CRUD operations and handle data fetching, saving, and updating.",
		  "class Usecase${2:Feature} {",
		  "  final RepositoryRemote${2:Feature} repositoryRemote;",
		  "  final RepositoryLocal${2:Feature} repositoryLocal;",
		  "",
		  "  Usecase${2:Feature}({",
		  "    required this.repositoryRemote,",
		  "    required this.repositoryLocal,",
		  "  });",
		  "",
		  "  /// Fetches a list of ${2:Feature} from the remote repository and saves them to the local repository.",
		  "  ///",
		  "  /// Returns a [Future] that completes with a tuple containing:",
		  "  /// - [ExptData] indicating the status of the local operation.",
		  "  /// - [ExptWeb] indicating the status of the remote operation.",
		  "  Future<({ExptData exptData, ExptWeb exptWeb})> fetch${2:Feature}() async {",
		  "    final resultWeb = await repositoryRemote.getList();",
		  "",
		  "    if (resultWeb.isEmpty) {",
		  "      return (",
		  "        exptData: ExptDataNoExpt(),",
		  "        exptWeb: ExptWebGet('Empty remote data', 1)",
		  "      );",
		  "    }",
		  "    final resultLocal = await repositoryLocal.saveList(resultWeb);",
		  "    if (resultLocal == 0) {",
		  "      return (",
		  "        exptWeb: ExptWebNoExpt(),",
		  "        exptData: ExptDataLoad('No local data save', 2)",
		  "      );",
		  "    }",
		  "    return (exptData: ExptDataNoExpt(), exptWeb: ExptWebNoExpt());",
		  "  }",
		  "",
		  "  /// Loads a list of ${2:Feature} from the local repository.",
		  "  ///",
		  "  /// Returns a [Future] that completes with a tuple containing:",
		  "  /// - [ExptData] indicating the status of the operation.",
		  "  /// - A list of [${3:ClassModel}Model] items.",
		  "  Future<({ExptData exception, List<${3:ClassModel}Model> list})>",
		  "      load${2:Feature}() async {",
		  "    try {",
		  "      final items = await repositoryLocal.getList();",
		  "      if (items.isNotEmpty) {",
		  "        return (",
		  "          exception: ExptDataNoExpt(),",
		  "          list: items,",
		  "        );",
		  "      }",
		  "      return (",
		  "        exception: ExptDataLoad('Empty local data', 1),",
		  "        list: List<${3:ClassModel}Model>.empty(),",
		  "      );",
		  "    } catch (e) {",
		  "      return (",
		  "        exception: ExptDataLoad(e.toString(), 1),",
		  "        list: List<${3:ClassModel}Model>.empty(),",
		  "      );",
		  "    }",
		  "  }",
		  "",
		  "  /// Updates a ${3:ClassModel} item in the local repository.",
		  "  ///",
		  "  /// [updateItem] is the item to be updated.",
		  "  ///",
		  "  /// Returns a [Future] that completes with a tuple containing:",
		  "  /// - [ExptData] indicating the status of the operation.",
		  "  /// - The updated [${3:ClassModel}Model] item.",
		  "  Future<({ExptData exception, ${3:ClassModel}Model item})> update${3:ClassModel}(",
		  "      ${3:ClassModel}Model updateItem) async {",
		  "    try {",
		  "      final idSaved = await repositoryLocal.updateItem(updateItem);",
		  "      if (idSaved > 0) {",
		  "        return (exception: ExptDataNoExpt(), item: updateItem);",
		  "      }",
		  "      return (",
		  "        exception: ExptDataSave('Error save item'),",
		  "        item: ${3:ClassModel}Model.init()",
		  "      );",
		  "    } catch (e) {",
		  "      return (",
		  "        exception: ExptDataSave(e.toString()),",
		  "        item: ${3:ClassModel}Model.init()",
		  "      );",
		  "    }",
		  "  }",
		  "",
		  "  /// Loads a single ${3:ClassModel} by its ID from the local repository.",
		  "  ///",
		  "  /// Returns a [Future] that completes with the [${3:ClassModel}Model] item.",
		  "  Future<({ExptData exception, ${3:ClassModel}Model item})> load${3:ClassModel}(",
		  "      int id) async {",
		  "    try {",
		  "      final item = await repositoryLocal.getItem(id);",
		  "      if (item.id != 0) {",
		  "        return (",
		  "          exception: ExptDataNoExpt(),",
		  "          item: item,",
		  "        );",
		  "      } else {",
		  "        return (",
		  "          exception: ExptDataLoad('Item not found', 1),",
		  "          item: ${3:ClassModel}Model.init(),",
		  "        );",
		  "      }",
		  "    } catch (e) {",
		  "      return (",
		  "        exception: ExptDataLoad(e.toString(), 1),",
		  "        item: ${3:ClassModel}Model.init(),",
		  "      );",
		  "    }",
		  "  }",
		  "",
		  "  /// Creates a new ${3:ClassModel} in the local repository.",
		  "  ///",
		  "  /// Returns a [Future] that completes with the ID of the created item.",
		  "  Future<({ExptData exception, int id})> create${3:ClassModel}(",
		  "      ${3:ClassModel}Model item) async {",
		  "    try {",
		  "      final id = await repositoryLocal.saveItem(item);",
		  "      if (id != 0) {",
		  "        return (",
		  "          exception: ExptDataNoExpt(),",
		  "          id: id,",
		  "        );",
		  "      } else {",
		  "        return (",
		  "          exception: ExptDataSave('Item not saved', 1),",
		  "          id: 0,",
		  "        );",
		  "      }",
		  "    } catch (e) {",
		  "      return (",
		  "        exception: ExptDataSave(e.toString(), 1),",
		  "        id: 0,",
		  "      );",
		  "    }",
		  "  }",
		  "",
		  "  /// Removes a single ${3:ClassModel} by its ID from the local repository.",
		  "  ///",
		  "  /// Returns a [Future] that completes with the ID of the removed item.",
		  "  Future<({ExptData exception, int id})> remove${3:ClassModel}(int id) async {",
		  "    try {",
		  "      final deletedId = await repositoryLocal.deleteItem(id);",
		  "      if (deletedId != 0) {",
		  "        return (",
		  "          exception: ExptDataNoExpt(),",
		  "          id: deletedId,",
		  "        );",
		  "      } else {",
		  "        return (",
		  "          exception: ExptDataDelete('Item not deleted', 1),",
		  "          id: 0,",
		  "        );",
		  "      }",
		  "    } catch (e) {",
		  "      return (",
		  "        exception: ExptDataDelete(e.toString(), 1),",
		  "        id: 0,",
		  "      );",
		  "    }",
		  "  }",
		  "",
		  "  /// Removes all ${2:Feature} from the local repository.",
		  "  ///",
		  "  /// Returns a [Future] that completes with the number of removed items.",
		  "  Future<({ExptData exception, int count})> removeAll${2:Feature}() async {",
		  "    try {",
		  "      final count = await repositoryLocal.deleteAll();",
		  "      return (",
		  "        exception: ExptDataNoExpt(),",
		  "        count: count,",
		  "      );",
		  "    } catch (e) {",
		  "      return (",
		  "        exception: ExptDataDelete(e.toString(), 1),",
		  "        count: 0,",
		  "      );",
		  "    }",
		  "  }",
		  "",
		  "  /// Fetches a ${3:ClassModel} item by its [id] from the remote repository and saves it to the local repository.",
		  "  ///",
		  "  /// Returns a [Future] that completes with a tuple containing:",
		  "  /// - [ExptData] indicating the status of the local operation.",
		  "  /// - [ExptWeb] indicating the status of the remote operation.",
		  "  Future<({ExptData exptData, ExptWeb exptWeb})> fetch${3:ClassModel}(int id) async {",
		  "    try {",
		  "      final itemWeb = await repositoryRemote.getItem(id);",
		  "      int idSaved = await repositoryLocal.saveItem(itemWeb);",
		  "      if (idSaved > 0) {",
		  "        return (exptData: ExptDataNoExpt(), exptWeb: ExptWebNoExpt());",
		  "      }",
		  "      return (",
		  "        exptData: ExptDataSave('Error save item', 1),",
		  "        exptWeb: ExptWebNoExpt(),",
		  "      );",
		  "    } catch (e) {",
		  "      return (exptData: ExptDataNoExpt(), exptWeb: ExptWebGet(e.toString(), 2));",
		  "    }",
		  "  }",
		  "",
		  "  /// Sends a ${3:ClassModel} item to the remote repository to be updated.",
		  "  ///",
		  "  /// [updateItem] is the item to be sent.",
		  "  ///",
		  "  /// Returns a [Future] that completes with a tuple containing:",
		  "  /// - [ExptWeb] indicating the status of the operation.",
		  "  /// - The updated [${3:ClassModel}Model] item.",
		  "  Future<({ExptWeb exception, ${3:ClassModel}Model item})> send${3:ClassModel}(",
		  "      ${3:ClassModel}Model updateItem) async {",
		  "    try {",
		  "      final itemUpdated = await repositoryRemote.putItem(",
		  "        id: updateItem.id,",
		  "        jsonData: updateItem.toJson(),",
		  "      );",
		  "",
		  "      return (",
		  "        exception: ExptWebPost(),",
		  "        item: itemUpdated,",
		  "      );",
		  "    } catch (e) {",
		  "      return (",
		  "        exception: ExptWebGet(e.toString(), 1),",
		  "        item: ${3:ClassModel}Model.init(),",
		  "      );",
		  "    }",
		  "  }",
		  "",
		  "  /// Receives all ${3:ClassModel} items from the remote repository.",
		  "  ///",
		  "  /// Returns a [Future] that completes with a tuple containing:",
		  "  /// - [ExptWeb] indicating the status of the operation.",
		  "  /// - A list of [${3:ClassModel}Model] items.",
		  "  Future<({ExptWeb exception, List<${3:ClassModel}Model> list})>",
		  "      receiveAll${2:Feature}() async {",
		  "    try {",
		  "      final list = await repositoryRemote.getList();",
		  "      if (list.isNotEmpty) {",
		  "        return (",
		  "          exception: ExptWebNoExpt(),",
		  "          list: list,",
		  "        );",
		  "      }",
		  "      return (",
		  "        exception: ExptWebGet('Empty remote data', 1),",
		  "        list: List<${3:ClassModel}Model>.empty(),",
		  "      );",
		  "    } catch (e) {",
		  "      return (",
		  "        exception: ExptWebGet(e.toString(), 1),",
		  "        list: List<${3:ClassModel}Model>.empty(),",
		  "      );",
		  "    }",
		  "  }",
		  "",
		  "  /// Receives a ${3:ClassModel} item by its [id] from the remote repository.",
		  "  ///",
		  "  /// Returns a [Future] that completes with a tuple containing:",
		  "  /// - [ExptWeb] indicating the status of the operation.",
		  "  /// - The received [${3:ClassModel}Model] item.",
		  "  Future<({ExptWeb exception, ${3:ClassModel}Model item})> receive${3:ClassModel}(",
		  "      int id) async {",
		  "    try {",
		  "      final item = await repositoryRemote.getItem(id);",
		  "",
		  "      return (",
		  "        exception: ExptWebPost(),",
		  "        item: item,",
		  "      );",
		  "    } catch (e) {",
		  "      return (",
		  "        exception: ExptWebGet(e.toString(), 1),",
		  "        item: ${3:ClassModel}Model.init(),",
		  "      );",
		  "    }",
		  "  }",
		  "}",
		  ""
		],
		"description": "create usecase for feature"
	  },
}